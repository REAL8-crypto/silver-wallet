import { useEffect, useState, useCallback } from 'react';
import { POOL_ASSETS, CURRENT_PRICES } from '../constants/poolAssets';

// Type guard to check if a string is a valid asset code
type ValidAssetCode = keyof typeof POOL_ASSETS;

function isValidAssetCode(code: string): code is ValidAssetCode {
  return code in POOL_ASSETS;
}

// Fetch last close price from Horizon (same function as in useReal8Stats)
async function fetchLastClosePrice(
    horizonBase: string,
    base: { type: 'native' | 'credit_alphanum4' | 'credit_alphanum12'; code?: string; issuer?: string },
    counter: { type: 'native' | 'credit_alphanum4' | 'credit_alphanum12'; code?: string; issuer?: string }
): Promise<number | null> {
    const end = Date.now();
    const start = end - 24 * 60 * 60 * 1000; // 24h
    const search = new URLSearchParams();

    search.set('base_asset_type', base.type);
    if (base.type !== 'native') {
        search.set('base_asset_code', base.code as string);
        search.set('base_asset_issuer', base.issuer as string);
    }

    search.set('counter_asset_type', counter.type);
    if (counter.type !== 'native') {
        search.set('counter_asset_code', counter.code as string);
        search.set('counter_asset_issuer', counter.issuer as string);
    }

    search.set('resolution', String(900_000)); // 15m
    search.set('start_time', String(start));
    search.set('end_time', String(end));
    search.set('limit', '200');
    search.set('order', 'asc');
    const url = `${horizonBase}/trade_aggregations?${search.toString()}`;

    try {
        const res = await fetch(url, { cache: 'no-store', mode: 'cors' });
        if (!res.ok) return null;

        const json = await res.json();
        const records: any[] = json?._embedded?.records || [];

        // Find the most recent record with actual trades
        for (let i = records.length - 1; i >= 0; i--) {
            const r = records[i];
            const tc = Number(r.trade_count || 0);
            const bv = parseFloat(r.base_volume || '0');
            const cv = parseFloat(r.counter_volume || '0');

            if (tc > 0 && bv > 0 && cv > 0) {
                const close = parseFloat(r.close);
                if (!Number.isNaN(close)) return close;
            }
        }

        return null;
    } catch (error) {
        console.warn(`Failed to fetch price for ${base.code || 'XLM'}/${counter.code || 'XLM'}:`, error);
        return null;
    }
}

const updateCurrentPrices = (newPrices: Record<string, number>) => {
    Object.keys(newPrices).forEach(code => {
        CURRENT_PRICES[code] = newPrices[code];
    });
}

export const useAssetPrices = () => {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const fetchAssetPrices = useCallback(async () => {
        setLoading(true);
        setError(null);

        try {
            const horizonBase = 'https://horizon.stellar.org'; // Use mainnet

            const newPrices: Record<string, number> = {};

            for (const assetCode of Object.keys(POOL_ASSETS)) {
                // Type guard check - skip if not a valid asset code
                if (!isValidAssetCode(assetCode)) {
                    console.warn(`Skipping unknown asset code: ${assetCode}`);
                    continue;
                }

                try {
                    let price: number | null = null;

                    if (assetCode === 'XLM') {
                        // Fetch XLM price against USD (or a stablecoin)
                        price = await fetchLastClosePrice(
                            horizonBase,
                            { type: 'native' },
                            { type: 'credit_alphanum4', code: 'USDC', issuer: 'GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN' }
                        );
                    } else {
                        // Fetch asset price against XLM
                        const asset = POOL_ASSETS[assetCode]; // TypeScript now knows this is safe

                        price = await fetchLastClosePrice(
                            horizonBase,
                            { type: 'credit_alphanum4', code: asset.code, issuer: asset.issuer },
                            { type: 'native' }
                        );
                    }

                    newPrices[assetCode] = price !== null ? price : CURRENT_PRICES[assetCode]; // Default to old price if fetch fails
                } catch (e) {
                    console.error(`Failed to fetch price for ${assetCode}:`, e);
                    setError(`Failed to fetch price for ${assetCode}`);
                    newPrices[assetCode] = CURRENT_PRICES[assetCode]; // Keep old price on error
                }
            }

            updateCurrentPrices(newPrices); // Update CURRENT_PRICES

        } catch (e: any) {
            console.error('Failed to fetch asset prices:', e);
            setError(e?.message || 'Failed to fetch asset prices');
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchAssetPrices();
        const interval = setInterval(fetchAssetPrices, 5 * 60 * 1000); // Update every 5 minutes

        return () => clearInterval(interval);
    }, [fetchAssetPrices]);

    return { loading, error };
};